type Query {
  user(id: ID, email: String): User
  service(id: ID!): Service
  booking(id: ID!): Booking
  users(
    name: String

    "Limits number of fetched items."
    first: Int! = 10

    "The offset from which items are returned."
    page: Int
  ): UserPaginator!
  services(
    name: String

    "Limits number of fetched items."
    first: Int! = 10

    "The offset from which items are returned."
    page: Int
  ): ServicePaginator!
  bookings(
    status: String

    "Limits number of fetched items."
    first: Int! = 10

    "The offset from which items are returned."
    page: Int
  ): BookingPaginator!
}

type Mutation {
  createService(name: String!, description: String): Service
  updateService(id: ID!, name: String, description: String): Service
  deleteService(id: ID!): Service

  "Create a new booking (must pass authenticated user_id)."
  createBooking(user_id: ID!, service_id: ID!, start_time: DateTime!, end_time: DateTime!, status: String): Booking

  updateBooking(id: ID!, start_time: DateTime, end_time: DateTime, status: String): Booking
  deleteBooking(id: ID!): Booking
}

"A datetime string with format `Y-m-d H:i:s`, e.g. `2025-10-26 14:30:00`."
scalar DateTime

type User {
  id: ID!
  name: String!
  email: String!
  email_verified_at: DateTime
  created_at: DateTime!
  updated_at: DateTime!
}

type Service {
  id: ID!
  name: String!
  description: String
  created_at: DateTime!
  updated_at: DateTime!
  bookings: [Booking!]!
}

type Booking {
  id: ID!
  user: User!
  service: Service!
  start_time: DateTime!
  end_time: DateTime!
  status: String!
}

"Information about pagination using a fully featured paginator."
type PaginatorInfo {
  "Number of items in the current page."
  count: Int!

  "Index of the current page."
  currentPage: Int!

  "Index of the first item in the current page."
  firstItem: Int

  "Are there more pages after this one?"
  hasMorePages: Boolean!

  "Index of the last item in the current page."
  lastItem: Int

  "Index of the last available page."
  lastPage: Int!

  "Number of items per page."
  perPage: Int!

  "Number of total available items."
  total: Int!
}

"A paginated list of User items."
type UserPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of User items."
  data: [User!]!
}

"A paginated list of Service items."
type ServicePaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Service items."
  data: [Service!]!
}

"A paginated list of Booking items."
type BookingPaginator {
  "Pagination information about the list of items."
  paginatorInfo: PaginatorInfo!

  "A list of Booking items."
  data: [Booking!]!
}

"Directions for ordering a list of records."
enum SortOrder {
  "Sort records in ascending order."
  ASC

  "Sort records in descending order."
  DESC
}

"Aggregate functions when ordering by a relation without specifying a column."
enum OrderByRelationAggregateFunction {
  "Amount of items."
  COUNT
}

"Aggregate functions when ordering by a relation that may specify a column."
enum OrderByRelationWithColumnAggregateFunction {
  "Average."
  AVG

  "Minimum."
  MIN

  "Maximum."
  MAX

  "Sum."
  SUM

  "Amount of items."
  COUNT
}

"Allows ordering a list of records."
input OrderByClause {
  "The column that is used for ordering."
  column: String!

  "The direction that is used for ordering."
  order: SortOrder!
}

"Specify if you want to include or exclude trashed results from a query."
enum Trashed {
  "Only return trashed results."
  ONLY

  "Return both trashed and non-trashed results."
  WITH

  "Only return non-trashed results."
  WITHOUT
}

